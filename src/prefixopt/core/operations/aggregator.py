"""
Модуль для агрегации IP-сетей.

Предоставляет функции для объединения (схлопывания) смежных подсетей
в более крупные блоки (суперсети). Использует оптимизированный стековый
алгоритм с линейной сложностью O(N).
"""
from typing import List, Union, Iterable

from ipaddress import IPv4Network, IPv6Network


def aggregate(
    networks: Iterable[Union[IPv4Network, IPv6Network]]
) -> List[Union[IPv4Network, IPv6Network]]:
    """
    Aggregates adjacent networks in a list.

    Объединяет соседние подсети одинакового размера в более крупные, если это возможно
    по правилам бинарной арифметики (выравнивание). Например, две сети /24 могут
    быть объединены в одну /23.

    Алгоритм:
        Используется стековый подход O(N). Проходим по отсортированному списку,
        складываем элементы в стек и рекурсивно пытаемся объединить вершину стека
        с предыдущим элементом.

    Требования:
        Входные данные ДОЛЖНЫ быть:
        1. Отсортированы (по адресу).
        2. Очищены от вложенностей (remove_nested).
        Если эти условия не выполнены, агрегация будет неполной или некорректной.

    Args:
        networks: Итератор или список объектов IPv4Network/IPv6Network.

    Returns:
        Список агрегированных (минимально возможных) сетей.
    """
    stack: List[Union[IPv4Network, IPv6Network]] = []

    for net in networks:
        # Добавляем новую сеть на вершину стека
        stack.append(net)

        # Пытаемся схлопнуть верхушку стека вниз, пока это возможно
        # (Рекурсивное объединение снизу вверх)
        while len(stack) >= 2:
            right = stack[-1]  # Последняя добавленная (верхняя)
            left = stack[-2]   # Предпоследняя

            # 1. Проверка совместимости протоколов и масок
            # Объединять можно только сети одной версии и одинакового размера
            if left.version != right.version or left.prefixlen != right.prefixlen:
                break

            # 2. Проверка смежности
            # Конец левой сети + 1 должен быть равен началу правой
            # Используем int() для получения числового представления адреса
            if int(left.broadcast_address) + 1 != int(right.network_address):
                break

            # 3. Проверка выравнивания
            # Две /24 могут склеиться в /23 только если они образуют корректный блок.
            # Левая сеть должна быть началом этого блока (четной).
            try:
                # Пытаемся получить суперсеть (уменьшаем маску на 1 бит)
                supernet = left.supernet(prefixlen_diff=1)
                
                # Если адрес суперсети совпадает с адресом левой подсети,
                # значит левая подсеть является корректным началом блока.
                if supernet.network_address == left.network_address:
                    # Успешное объединение:
                    stack.pop() # Убираем right
                    stack.pop() # Убираем left
                    stack.append(supernet) # Кладем объединенную суперсеть
                    
                    # continue возвращает нас в начало while, чтобы проверить, 
                    # не склеится ли новая суперсеть с тем, что лежит под ней в стеке.
                    continue 
            except (ValueError, IndexError):
                # ValueError: если сеть /0 и нельзя расширить.
                # IndexError: защита от неожиданных ошибок ipaddress.
                pass
            
            # Если ни одно условие объединения не сработало - прерываем цикл сжатия
            # для текущего элемента и переходим к следующему из входного потока.
            break

    return stack